---
import "../styles/global.css";
import Menu from "../components/Menu.astro";
import SearchHistory from "../components/SearchHistory.astro";
import DailyProgressBar from "../components/DailyProgressBar.astro";
import TimeInfo from "../components/TimeInfo.astro";
import DynamicGreeting from "../components/DynamicGreeting.astro";
---
<!DOCTYPE html>
<html lang="en">
<head>
      <script is:inline>
    // The configured mode is stored in local storage
    const theme = localStorage.getItem("themePreference");
    // Put dark class on html tag to enable dark mode
    document.querySelector("html").className = theme;
  </script>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minimal Search</title>   

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <!-- Casual Font CDN -->
    <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap" rel="stylesheet">
    <!-- Schoolbell Font CDN -->
    <link href="https://fonts.googleapis.com/css2?family=Schoolbell&display=swap" rel="stylesheet">
    <!-- Phosphor Icons CDN for filled icons -->
    <!-- Tailwind CSS CDN with custom config to match existing colors -->

  
    <style type="text/css">
        /* CSS Variables for theming */
        :root {
            --color-primary-bg: 240 240 240;
            --color-secondary-bg: 224 224 224;
            --color-border-color: 187 187 187;
            --color-text-primary: 26 26 26;
            --color-text-secondary: 68 68 68;
            --color-text-placeholder: 119 119 119;
            --color-accent: 136 136 136;
            --color-radio-selected-bg: 221 221 221;
            --color-radio-selected-dot: 26 26 26;
        }

        html.dark {
            --color-primary-bg: 26 26 26;
            --color-secondary-bg: 42 42 42;
            --color-border-color: 68 68 68;
            --color-text-primary: 240 240 240;
            --color-text-secondary: 204 204 204;
            --color-text-placeholder: 136 136 136;
            --color-accent: 255 255 255;
            --color-radio-selected-bg: 85 85 85;
            --color-radio-selected-dot: 255 255 255;
        }

        /* Global transition for all elements for smoother UI */
        * {
            transition-property: all;
            transition-timing-function: ease-out;
            transition-duration: 0.2s;
        }

        /* Body font */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Specific styles not easily replaced by Tailwind without breaking design */
        /* Active line indicator - now a single element */
        #active-line {
            position: absolute;
            bottom: 0;
            height: 2px;
            border-radius: 1px;
            transition: left 0.3s ease-out, width 0.3s ease-out; /* Sliding animation */
            z-index: 10; /* Ensure it's on top */
            background-color: rgb(var(--color-text-primary)); /* Use theme variable for color */
        }

        /* Loading indicator animation */
        #loading-indicator {
            animation: slide-fade 1s infinite cubic-bezier(0.65, 0.05, 0.36, 1);
        }

        /* Keyframes for slide-fade animation */
        @keyframes slide-fade {
            0% { opacity: 0; transform: translateX(-50px); }
            25% { opacity: 1; transform: translateX(0); }
            75% { opacity: 1; transform: translateX(50px); }
            100% { opacity: 0; transform: translateX(100px); }
        }

        /* Hide the actual radio button visually */
        .custom-radio {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        /* Webkit browsers (Chrome, Safari) scrollbar styles */
        .history-list::-webkit-scrollbar {
            width: 6px; /* width of the scrollbar */
        }

        .history-list::-webkit-scrollbar-track {
            background: transparent; /* color of the tracking area */
        }

        .history-list::-webkit-scrollbar-thumb {
            background-color: rgb(var(--color-border-color)); /* Light mode thumb color */
            border-radius: 10px; /* roundness of the scroll thumb */
            border: 1px solid rgb(var(--color-secondary-bg)); /* Light mode border color */
        }

        /* Dark mode scrollbar thumb */
        html.dark .history-list::-webkit-scrollbar-thumb {
            background-color: rgb(var(--color-border-color)); /* Dark mode thumb color */
            border: 1px solid rgb(var(--color-secondary-bg)); /* Dark mode border color */
        }

        /* Firefox scrollbar styles */
        .history-list {
            scrollbar-width: thin;
            scrollbar-color: rgb(var(--color-border-color)) transparent; /* Light mode thumb and track color */
        }

        /* Dark mode Firefox scrollbar */
        html.dark .history-list {
            scrollbar-color: rgb(var(--color-border-color)) transparent; /* Dark mode thumb and track color */
        }

      
        /* Goal Context Menu specific styles for visibility transition */
        #goal-context-menu {
            display: flex; /* Keep flex display always */
            visibility: hidden; /* Start hidden for transitions */
            opacity: 0;
            pointer-events: none; /* Prevent clicks when hidden */
            transition: opacity 0.2s ease-out, visibility 0.2s ease-out;
        }

        #goal-context-menu.show {
            visibility: visible;
            opacity: 1;
            pointer-events: auto;
        }

        /* Edit Goal Section (Modal Overlay) specific styles for visibility transition */
        #edit-goal-section {
            transition: opacity 0.15s ease-out; /* Fast fade for overlay */
        }
        #edit-goal-section.show {
            opacity: 1;
            pointer-events: auto;
        }
        /* Modal inside edit goal section for slide effect */
        #edit-goal-section .edit-goal-modal {
            transform: translateY(-100%); /* Start completely off-screen top */
            transition: transform 0.15s ease-out; /* Fast slide */
        }
        #edit-goal-section.show .edit-goal-modal {
            transform: translateY(0); /* Slide into view */
        }


     

        
        #top-elements.with-engine #engine-selection {
            flex-shrink: 0;
            flex-grow: 0;
        }
    </style>
    <!-- Inline script to prevent theme flicker -->
   
</head>
<body class="bg-[rgb(var(--color-primary-bg))] text-[rgb(var(--color-text-primary))] flex items-center justify-center min-h-screen p-4 antialiased
             dark:bg-[rgb(var(--color-primary-bg))] dark:text-[rgb(var(--color-text-primary))]">
    <!-- Blank screen overlay for transition -->
    <div id="blank-screen-overlay" class="fixed inset-0 opacity-0 pointer-events-none z-[9999] transition-opacity duration-50 flex items-center justify-center
             bg-[rgb(var(--color-primary-bg))] dark:bg-[rgb(var(--color-primary-bg))]">
        <div id="loading-indicator" class="w-[50px] h-1 bg-[rgb(var(--color-accent))] rounded-sm opacity-0 dark:bg-[rgb(var(--color-accent))]"></div>
    </div>

    <!-- Goal Context Menu (Right-click) -->
    <div id="goal-context-menu" class="context-menu absolute bg-[rgb(var(--color-secondary-bg))] border border-[rgb(var(--color-border-color))] rounded-sm shadow-lg z-50 flex-col min-w-[120px] py-1
             dark:bg-[rgb(var(--color-secondary-bg))] dark:border-[rgb(var(--color-border-color))]">
        <div class="context-menu-item px-4 py-2 text-[rgb(var(--color-text-primary))] text-sm cursor-pointer whitespace-nowrap hover:bg-[rgb(var(--color-border-color))]
                    dark:text-[rgb(var(--color-text-primary))] dark:hover:bg-[rgb(var(--color-border-color))]" data-action="completed">Completed</div>
        <div class="context-menu-item px-4 py-2 text-[rgb(var(--color-text-primary))] text-sm cursor-pointer whitespace-nowrap hover:bg-[rgb(var(--color-border-color))]
                    dark:text-[rgb(var(--color-text-primary))] dark:hover:bg-[rgb(var(--color-border-color))]" data-action="delete">Delete</div>
    </div>

    <div class="container-wrapper w-full max-w-3xl flex flex-col gap-4 relative">
        <!-- New Edit Goal Section - For single goal edit, appears from top -->
        <div id="edit-goal-section" class="fixed inset-0 bg-black bg-opacity-30 flex justify-center items-start z-[10000] opacity-0 pointer-events-none">
            <div class="edit-goal-modal bg-[rgb(var(--color-secondary-bg))] border border-[rgb(var(--color-border-color))] rounded-sm p-2 flex flex-row items-center gap-2 w-[90%] max-w-xl shadow-none mt-4 focus-within:border-[rgb(var(--color-accent))] focus-within:shadow-md
                        dark:bg-[rgb(var(--color-secondary-bg))] dark:border-[rgb(var(--color-border-color))] dark:focus-within:border-[rgb(var(--color-accent))]">
                <label for="edit-goal-input" class="text-[rgb(var(--color-text-secondary))] text-sm flex flex-col gap-1 flex-grow
                                            dark:text-[rgb(var(--color-text-secondary))]">
                    <input type="text" id="edit-goal-input" placeholder="Edit your goal title" class="bg-[rgb(var(--color-primary-bg))] border border-[rgb(var(--color-border-color))] rounded-sm px-2 py-1.5 text-[rgb(var(--color-text-primary))] text-base w-full box-border focus:outline-none focus:border-[rgb(var(--color-accent))]
                                            dark:bg-[rgb(var(--color-primary-bg))] dark:border-[rgb(var(--color-border-color))] dark:text-[rgb(var(--color-text-primary))] dark:focus:border-[rgb(var(--color-accent))]">
                </label>
                <div class="button-group flex flex-row gap-1 items-center ml-auto">
                    <button id="edit-goal-action-button" class="bg-[rgb(var(--color-accent))] text-[rgb(var(--color-primary-bg))] px-2.5 py-1.5 border-none rounded-sm cursor-pointer font-semibold text-xs transition-colors duration-200 hover:bg-[rgb(var(--color-text-secondary))]
                                            dark:bg-[rgb(var(--color-accent))] dark:text-[rgb(var(--color-primary-bg))] dark:hover:bg-[rgb(var(--color-text-secondary))]"></button> <!-- This will be Save or Completed -->
                    <button id="edit-goal-delete-button" class="delete-button bg-[rgb(var(--color-border-color))] text-[rgb(var(--color-text-primary))] px-2.5 py-1.5 border-none rounded-sm cursor-pointer font-semibold text-xs transition-colors duration-200 hover:bg-red-500 hover:text-white
                                            dark:bg-[rgb(var(--color-border-color))] dark:text-[rgb(var(--color-text-primary))]">Delete</button>
                </div>
            </div>
        </div>

        <!-- Top elements: Time Info and dynamically moved Engine Selection -->
        <div id="top-elements" class="flex   justify-between gap-4 items-start w-full">


            <TimeInfo />



            <!-- The engine-selection element will be dynamically moved here or in main-content-bottom -->
        </div>

        <div class="search-area-wrapper flex flex-col bg-[rgb(var(--color-secondary-bg))] border-2 border-[rgb(var(--color-border-color))] rounded-sm p-1 relative focus-within:border-[rgb(var(--color-accent))]
                    dark:bg-[rgb(var(--color-secondary-bg))] dark:border-[rgb(var(--color-border-color))] dark:focus-within:border-[rgb(var(--color-accent))]">
            <form id="search-form" class="search-form w-full flex-grow mt-0">
                <div class="input-wrapper relative flex items-center w-full">
                    <input
                        type="text"
                        id="search-input"
                        name="query"
                        class="search-input w-full bg-transparent border-none rounded-none pt-1.5 pb-1.5 pl-2 pr-10 text-[rgb(var(--color-text-primary))] text-base md:text-lg leading-relaxed placeholder:text-[rgb(var(--color-text-placeholder))] focus:outline-none
                                dark:text-[rgb(var(--color-text-primary))] dark:placeholder:text-[rgb(var(--color-text-placeholder))]"
                        placeholder="Search Google..."
                        autocomplete="off"
                    />
                    <button type="submit" class="search-button absolute right-0 mr-2 text-[rgb(var(--color-text-secondary))] cursor-pointer bg-none border-none p-0 flex items-center justify-center hover:text-[rgb(var(--color-text-primary))]
                                dark:text-[rgb(var(--color-text-secondary))] dark:hover:text-[rgb(var(--color-text-primary))]" aria-label="Search">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="search-icon w-5 h-5">
                            <path d="m21 21-4.35-4.35m0 0A7.5 7.5 0 1 0 6.5 6.5a7.5 7.5 0 0 0 10.2 10.2Z"/>
                        </svg>
                    </button>
                </div>
            </form>
        </div>

        <!-- Main content bottom: Engine Selection (if goals hidden), Goals, Daily Progress -->
        <div id="main-content-bottom" class="flex flex-col sm:flex-row gap-4 w-full justify-between items-center">
            <div id="engine-selection" class="engine-selection flex flex-row  items-start gap-2 sm:gap-3 pl-1 relative">
                <label class="engine-label flex flex-col items-center gap-1 cursor-pointer relative py-0.5 min-w-[3rem] sm:min-w-[4rem]" title="Switch to Google search (G)">
                    <input type="radio" name="engine" value="google" class="custom-radio" checked>
                    <span class="radio-text font-medium text-[rgb(var(--color-text-secondary))] whitespace-nowrap uppercase text-xs px-0.5 hover:text-[rgb(var(--color-text-primary))]
                                dark:text-[rgb(var(--color-text-secondary))] dark:hover:text-[rgb(var(--color-text-primary))]">Google</span>
                </label>
                <label class="engine-label flex flex-col items-center gap-1 cursor-pointer relative py-0.5 min-w-[3rem] sm:min-w-[4rem]" title="Switch to Perplexity search (P)">
                    <input type="radio" name="engine" value="perplexity" class="custom-radio">
                    <span class="radio-text font-medium text-[rgb(var(--color-text-secondary))] whitespace-nowrap uppercase text-xs px-0.5 hover:text-[rgb(var(--color-text-primary))]
                                dark:text-[rgb(var(--color-text-secondary))] dark:hover:text-[rgb(var(--color-text-primary))]">Perplexity</span>
                </label>
                <label class="engine-label flex flex-col items-center gap-1 cursor-pointer relative py-0.5 min-w-[3rem] sm:min-w-[4rem]" title="Switch to YouTube search (Y)">
                    <input type="radio" name="engine" value="youtube" class="custom-radio">
                    <span class="radio-text font-medium text-[rgb(var(--color-text-secondary))] whitespace-nowrap uppercase text-xs px-0.5 hover:text-[rgb(var(--color-text-primary))]
                                dark:text-[rgb(var(--color-text-secondary))] dark:hover:text-[rgb(var(--color-text-primary))]">YouTube</span>
                </label>
                <label class="engine-label flex flex-col items-center gap-1 cursor-pointer relative py-0.5 min-w-[3rem] sm:min-w-[4rem]" title="Switch to ChatGPT search (C)">
                    <input type="radio" name="engine" value="chatgpt" class="custom-radio">
                    <span class="radio-text font-medium text-[rgb(var(--color-text-secondary))] whitespace-nowrap uppercase text-xs px-0.5 hover:text-[rgb(var(--color-text-primary))]
                                dark:text-[rgb(var(--color-text-secondary))] dark:hover:text-[rgb(var(--color-text-primary))]">ChatGPT</span>
                </label>
                <label class="engine-label flex flex-col items-center gap-1 cursor-pointer relative py-0.5 min-w-[3rem] sm:min-w-[4rem]" title="View search history (H)">
                    <input type="radio" name="engine" value="history" class="custom-radio">
                    <span class="radio-text font-medium text-[rgb(var(--color-text-secondary))] whitespace-nowrap uppercase text-xs px-0.5 hover:text-[rgb(var(--color-text-primary))]
                                dark:text-[rgb(var(--color-text-secondary))] dark:hover:text-[rgb(var(--color-text-primary))]">History</span>
                </label>
                <div id="active-line" class="bg-[rgb(var(--color-text-primary))]"></div> <!-- Single active line for sliding effect -->
            </div>

            <div class="goals-container w-full flex-grow max-w-none pr-0 grid grid-cols-2 gap-4 items-start" id="goals-container">
                <!-- Goals or "Click here to set up" message will be rendered here -->
            </div>
            <DailyProgressBar />
            
        </div>

        <SearchHistory />
    </div>

        <Menu />

    <DynamicGreeting />

    <script>
        // --- Function Definitions (All moved to top for scope) ---

        const searchEnginePlaceholders = {
            google: "Search Google...",
            perplexity: "Search Perplexity...",
            youtube: "Search YouTube...",
            chatgpt: "Search ChatGPT...",
            history: "View search history or search Google..." // Special case for history
        };

        

    

        function getGoals() {
            try {
                const goalsString = localStorage.getItem('userGoals');
                return goalsString ? JSON.parse(goalsString) : [];
            } catch (e) {
                console.error("Error parsing goals from localStorage:", e);
                return [];
            }
        }

        function saveGoals(goalsArray) {
            try {
                localStorage.setItem('userGoals', JSON.stringify(goalsArray));
            } catch (e) {
                console.error("Error saving goals to localStorage:", e);
            }
        }

        function renderGoals() {
            const userGoals = getGoals(); // Get only user-defined goals

            goalsContainer.innerHTML = ''; // Clear existing goals/button

            const maxVisibleSlots = 2; // Always aim for 2 slots

            for (let i = 0; i < maxVisibleSlots; i++) {
                if (userGoals[i]) {
                    // Render existing user goal
                    const goalItem = document.createElement('div');
                    goalItem.className = 'goal-item flex flex-row items-center gap-2 py-1 border rounded-sm text-xs font-medium min-h-[2.2rem] box-border whitespace-nowrap overflow-hidden text-ellipsis cursor-pointer justify-start relative hover:border-[rgb(var(--color-accent))] hover:bg-[rgb(var(--color-secondary-bg))] hover:text-[rgb(var(--color-text-primary))] ' +
                                        'border-[rgb(var(--color-border-color))] text-[rgb(var(--color-text-primary))] '; /* Apply unified styling */
                    goalItem.dataset.index = i;
                    goalItem.innerHTML = `
                        <i class="ph-fill ph-clipboard-text goal-icon text-base flex-shrink-0 ml-2 group-hover:text-[rgb(var(--color-text-primary))] ' +
                                        'text-[rgb(var(--color-text-secondary))]"></i>
                        <span class="goal-title text-xs font-medium whitespace-nowrap overflow-hidden text-ellipsis flex-grow ' +
                                        'text-[rgb(var(--color-text-primary))]">${userGoals[i].text}</span>
                        <span class="time-since text-[0.7rem] font-normal whitespace-nowrap ml-auto flex-shrink-0 mr-2 ' +
                                        'text-[rgb(var(--color-text-secondary))]">${userGoals[i].creationTime ? formatTimeAgo(userGoals[i].creationTime) : ''}</span>
                    `;
                    goalItem.addEventListener('click', (e) => {
                        showEditGoalPopup(e, i, false);
                    });
                    goalItem.addEventListener('contextmenu', (e) => showGoalContextMenu(e, i, false));
                    goalsContainer.appendChild(goalItem);
                } else {
                    // Render "Click here to add goal" card
                    const setupPrompt = document.createElement('div');
                    setupPrompt.className = 'add-goal-prompt flex flex-row items-center gap-2 py-1 border border-dashed rounded-sm text-xs font-medium min-h-[2.2rem] box-border whitespace-nowrap overflow-hidden text-ellipsis cursor-pointer justify-start relative hover:border-[rgb(var(--color-accent))] hover:bg-[rgb(var(--color-secondary-bg))] hover:text-[rgb(var(--color-text-primary))] ' +
                                            'border-[rgb(var(--color-border-color))] text-[rgb(var(--color-text-secondary))] '; /* Apply unified styling */
                    setupPrompt.innerHTML = `
                        <i class="ph-fill ph-clipboard-text goal-icon text-base flex-shrink-0 ml-2 group-hover:text-[rgb(var(--color-text-primary))] ' +
                                        'text-[rgb(var(--color-text-secondary))]"></i>
                        <span>Click here to add your next goal</span>
                    `;
                    setupPrompt.addEventListener('click', (e) => {
                        showEditGoalPopup(e, -1, true); // isNewGoal true for new goal
                    });
                    goalsContainer.appendChild(setupPrompt);
                }
            }
        }

        let currentEditGoalIndex = -1;
        let isEditingNewGoal = false; // Renamed from isEditingDefaultGoal for clarity
        let originalGoalText = '';

        function showEditGoalPopup(e, index, isNewGoal = false) { // Renamed isDefault to isNewGoal
            e.stopPropagation();
            currentEditGoalIndex = index;
            isEditingNewGoal = isNewGoal;

            let goalText = '';
            if (!isNewGoal) { // If it's an existing goal
                const currentGoals = getGoals();
                const goalToEdit = currentGoals[index];
                goalText = goalToEdit ? goalToEdit.text : '';
            }
            // If isNewGoal is true (clicked "add goal" prompt), goalText remains empty, which is correct for new goal.

            originalGoalText = goalText;
            editGoalInput.value = goalText;
            editGoalSection.classList.add('show');
            editGoalInput.focus();

            updateActionButtonText();
        }

        function hideEditGoalPopup() {
            editGoalSection.classList.remove('show');
            currentEditGoalIndex = -1;
            isEditingNewGoal = false;
            originalGoalText = '';
        }

        function updateActionButtonText() {
            if (editGoalInput.value.trim() !== originalGoalText.trim()) {
                editGoalActionButton.textContent = "Save";
            } else {
                editGoalActionButton.textContent = "Completed";
            }
        }

        function handleEditGoalAction() {
            if (editGoalActionButton.textContent === "Save") {
                handleSaveGoal();
            } else if (editGoalActionButton.textContent === "Completed") {
                handleCompleteGoal();
            }
        }

        function handleSaveGoal() {
            const newText = editGoalInput.value.trim();
            if (!newText) {
                console.warn("Goal title cannot be empty.");
                return;
            }

            let userGoals = getGoals(); // Get all current goals

            if (isEditingNewGoal) {
                // If it was a new goal being added
                userGoals.push({ text: newText, creationTime: new Date().toISOString() });
            } else {
                // If an existing user goal was edited, update it
                if (currentEditGoalIndex !== -1 && currentEditGoalIndex < userGoals.length) {
                    userGoals[currentEditGoalIndex].text = newText;
                }
            }
            saveGoals(userGoals);
            renderGoals();
            hideEditGoalPopup();
        }

        function handleCompleteGoal() {
            if (isEditingNewGoal) { // If it's the "add goal" prompt, just close
                hideEditGoalPopup();
                return;
            }

            let userGoals = getGoals();
            if (currentEditGoalIndex !== -1 && currentEditGoalIndex < userGoals.length) {
                userGoals.splice(currentEditGoalIndex, 1);
                saveGoals(userGoals);
                renderGoals();
            }
            hideEditGoalPopup();
        }

        function handleDeleteGoal() {
            if (isEditingNewGoal) { // If it's the "add goal" prompt, just close
                hideEditGoalPopup();
                return;
            }

            let userGoals = getGoals();
            if (currentEditGoalIndex !== -1 && currentEditGoalIndex < userGoals.length) {
                userGoals.splice(currentEditGoalIndex, 1);
                saveGoals(userGoals);
                renderGoals();
            }
            hideGoalContextMenu(); // Ensure context menu is hidden
            hideEditGoalPopup(); // Ensure edit popup is hidden
        }


        function showGoalContextMenu(e, index, isNewGoal = false) { // Renamed isDefault to isNewGoal
            e.preventDefault();
            if (isNewGoal) return; // Right-click does nothing on the "add goal" prompt

            const currentGoals = getGoals();
            if (index < 0 || index >= currentGoals.length) return;

            goalContextMenu.classList.add('show');
            goalContextMenu.style.left = `${e.clientX}px`;
            goalContextMenu.style.top = `${e.clientY}px`;
            goalContextMenu.dataset.goalIndex = index;
            // Set visibility immediately for context menu
            goalContextMenu.style.visibility = 'visible';
            goalContextMenu.style.pointerEvents = 'auto';
        }

        function hideGoalContextMenu() {
            goalContextMenu.classList.remove('show');
            goalContextMenu.removeAttribute('data-goal-index');
            // Use a timeout to hide visibility after transition completes
            setTimeout(() => {
                goalContextMenu.style.visibility = 'hidden';
                goalContextMenu.style.pointerEvents = 'none';
            }, 200); // Match transition-duration of opacity/transform
        }

        function handleContextMenuAction(action) {
            const index = parseInt(goalContextMenu.dataset.goalIndex, 10);
            if (isNaN(index)) return;

            let userGoals = getGoals();
            if (index >= 0 && index < userGoals.length) {
                if (action === 'completed' || action === 'delete') {
                    userGoals.splice(index, 1);
                    saveGoals(userGoals);
                    renderGoals();
                }
            }
            hideGoalContextMenu();
        }

        

        function updateGoalTimeSince() {
            // Only render goals if they are enabled
            if (goalsEnabled) {
                renderGoals();
            }
        }

        function updateActiveLinePosition() {
            const currentRadio = document.querySelector('input[name="engine"]:checked');
            const activeLineElement = document.getElementById('active-line');
            if (currentRadio && activeLineElement) {
                const parentLabel = currentRadio.closest('.engine-label');
                if (parentLabel) {
                    // Get the position and size relative to the parent .engine-selection
                    const parentRect = engineSelection.getBoundingClientRect();
                    const labelRect = parentLabel.getBoundingClientRect();

                    const newLeft = `${labelRect.left - parentRect.left}px`;
                    const newWidth = `${labelRect.width}px`;

                    activeLineElement.style.left = newLeft;
                    activeLineElement.style.width = newWidth;
                }
            }
        }

        function updateActiveLineAndSections() {
            let historySelected = false;
            radioButtons.forEach(radio => {
                if (radio.checked) {
                    // Update search input placeholder based on selected engine
                    searchInput.placeholder = searchEnginePlaceholders[radio.value];
                    if (radio.value === 'history') {
                        historySelected = true;
                    }
                }
            });

            // Defer updateActiveLinePosition to ensure layout is stable
            setTimeout(updateActiveLinePosition, 0);

            // Dispatch custom events to control the search history component's visibility
            if (historySelected) {
                document.dispatchEvent(new CustomEvent('show-history'));
            } else {
                document.dispatchEvent(new CustomEvent('hide-history'));
            }
        }

        // --- Element References ---
        const searchForm = document.getElementById('search-form');
        const searchInput = document.getElementById('search-input');
        const radioButtons = document.querySelectorAll('input[name="engine"]');
        
        const blankScreenOverlay = document.getElementById('blank-screen-overlay');
        const engineSelection = document.getElementById('engine-selection'); // Reference to the engine selection container
        const searchHistorySection = document.getElementById('search-history-section');

        const goalsContainer = document.getElementById('goals-container');
        const goalContextMenu = document.getElementById('goal-context-menu');

        const editGoalSection = document.getElementById('edit-goal-section');
        const editGoalInput = document.getElementById('edit-goal-input');
        const editGoalActionButton = document.getElementById('edit-goal-action-button');
        const editGoalDeleteButton = document.getElementById('edit-goal-delete-button');

        

        

        const topElementsContainer = document.getElementById('top-elements');
        const mainContentBottomContainer = document.getElementById('main-content-bottom');

        let isCtrlPressed = false;
        let goalsEnabled = false; // State variable for goals visibility

        

        


        function updateLayout() {
            if (goalsEnabled) {
                goalsContainer.classList.remove('hidden');
                // Move engine-selection to top-elements
                topElementsContainer.appendChild(engineSelection);
                topElementsContainer.classList.add('with-engine');
            } else {
                goalsContainer.classList.add('hidden');
                // Move engine-selection to main-content-bottom
                mainContentBottomContainer.prepend(engineSelection); // Add to the beginning of bottom section
                topElementsContainer.classList.remove('with-engine');
            }
            renderGoals(); // Re-render goals based on new visibility state
            // Ensure updateActiveLinePosition runs after DOM changes are processed
            setTimeout(updateActiveLinePosition, 0); 
        }


        // Event listener for context menu items
        goalContextMenu.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (action) {
                handleContextMenuAction(action);
            }
        });

        // Hide context menu, edit goal popup if clicked anywhere outside them
        document.addEventListener('click', (e) => {
            if (!goalContextMenu.contains(e.target) && goalContextMenu.classList.contains('show')) {
                hideGoalContextMenu();
            }
            // Check if the click is outside the edit goal modal and it's currently shown
            if (editGoalSection.classList.contains('show') && !editGoalModal.contains(e.target)) {
                hideEditGoalPopup();
            }
            
        });

        // Add escape key listener
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (editGoalSection.classList.contains('show')) {
                    hideEditGoalPopup();
                }
                
                // If escape is pressed and the search input is focused, blur it
                if (document.activeElement === searchInput) {
                    searchInput.blur();
                }
            }
        });

        // Add Enter key listener for the goal input
        editGoalInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent default form submission or new line
                handleEditGoalAction();
            }
        });

        // Listen for changes on radio buttons to update the active line and sections visibility
        radioButtons.forEach(radio => {
            radio.addEventListener('change', updateActiveLineAndSections);
        });

        // Clear history button listener
       

        // Track Ctrl/Cmd key state
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Control' || e.key === 'Meta') {
                isCtrlPressed = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Control' || e.key === 'Meta') {
                isCtrlPressed = false;
            }
        });

        // --- Form Submission Logic ---
        function performSearch(query, selectedEngine, openInNewTab = false) {
            if (!query) return;

            // If history is active, switch to Google before searching
            if (selectedEngine === 'history') {
                const googleRadio = document.querySelector('input[name="engine"][value="google"]');
                if (googleRadio) {
                    googleRadio.checked = true;
                    googleRadio.dispatchEvent(new Event('change')); // Trigger change to update UI
                    selectedEngine = 'google'; // Update selectedEngine for the URL construction
                }
            }

            let url = '';
            switch (selectedEngine) {
                case 'google':
                    url = `https://www.google.com/search?q=${encodeURIComponent(query)}`;
                    break;
                case 'perplexity':
                    url = `https://www.perplexity.ai/search?q=${encodeURIComponent(query)}`;
                    break;
                case 'youtube':
                    url = `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`;
                    break;
                case 'chatgpt':
                    url = `https://chat.openai.com/chat?q=${encodeURIComponent(query)}`;
                    break;
                // No default case needed as history is handled above and other cases are explicit
            }

            if (selectedEngine !== 'history') { // Only add to history if it's an actual search engine
                document.dispatchEvent(new CustomEvent('add-to-history', {
                detail: { query, selectedEngine }
                }));

}

            // Only show blank screen overlay if not opening in a new tab
            if (!openInNewTab) {
                blankScreenOverlay.style.opacity = '1';
                blankScreenOverlay.style.pointerEvents = 'auto';
                setTimeout(() => {
                    window.location.href = url;
                }, 200);
            } else {
                window.open(url, '_blank');
            }
        }

        searchForm.addEventListener('submit', function (e) {
            e.preventDefault();
            let query = searchInput.value.trim();
            let selectedEngine = document.querySelector('input[name="engine"]:checked').value;
            performSearch(query, selectedEngine, isCtrlPressed); // Use isCtrlPressed for new tab behavior
        });

        // New helper function for engine switching logic
        function handleEngineSwitch(key) {
            let targetEngine = null;
            if (key === 'p') {
                targetEngine = 'perplexity';
            } else if (key === 'g') {
                targetEngine = 'google';
            } else if (key === 'y') {
                targetEngine = 'youtube';
            } else if (key === 'c') {
                targetEngine = 'chatgpt';
            } else if (key === 'h') {
                targetEngine = 'history';
            } else if (key === 'arrowleft' || key === 'arrowright') {
                const currentRadio = document.querySelector('input[name="engine"]:checked');
                let currentIndex = -1;
                const engineLabels = Array.from(document.querySelectorAll('.engine-label input[name="engine"]'));

                for (let i = 0; i < engineLabels.length; i++) {
                    if (engineLabels[i] === currentRadio) {
                        currentIndex = i;
                        break;
                    }
                }

                let newIndex = currentIndex;
                if (key === 'arrowright') {
                    newIndex = (currentIndex + 1) % engineLabels.length;
                } else if (key === 'arrowleft') {
                    newIndex = (currentIndex - 1 + engineLabels.length) % engineLabels.length;
                }

                if (newIndex !== currentIndex) {
                    engineLabels[newIndex].checked = true;
                    engineLabels[newIndex].dispatchEvent(new Event('change'));
                }
                return; // Exit to prevent other keydown logic from interfering
            }

            if (targetEngine) {
                const radioToSelect = document.querySelector(`input[name="engine"][value="${targetEngine}"]`);
                if (radioToSelect) {
                    radioToSelect.checked = true;
                    radioToSelect.dispatchEvent(new Event('change'));
                }
            }
        }

        // --- Keyboard Shortcut Logic ---
        document.addEventListener('keydown', function(e) {
            const key = e.key.toLowerCase();
            const isInputActive = document.activeElement.tagName === 'INPUT' ||
                                  document.activeElement.tagName === 'TEXTAREA' ||
                                  document.activeElement.tagName === 'SELECT';

            // Define the keys that trigger engine switching
            const engineSwitchKeys = ['p', 'g', 'y', 'c', 'h', 'arrowleft', 'arrowright'];

            // Check if an engine switch key is pressed
            if (engineSwitchKeys.includes(key)) {
                // If search input is active, require Alt key for engine switching
                if (isInputActive) {
                    if (e.altKey) {
                        e.preventDefault(); // Prevent default browser behavior
                        handleEngineSwitch(key);
                    }
                } else { // If search input is NOT active, allow engine switching without Alt key
                    e.preventDefault(); // Prevent default browser behavior (e.g., 'h' for help)
                    handleEngineSwitch(key);
                }
            }

            // Handle Ctrl/Cmd + Enter (always active, opens in new tab)
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault(); // Prevent default browser behavior
                let query = searchInput.value.trim();
                if (query) {
                    let selectedEngine = document.querySelector('input[name="engine"]:checked').value;
                    performSearch(query, selectedEngine, true); // Force open in new tab
                }
                return; // Exit to prevent other Enter key logic from interfering
            }

            // Handle Enter key (when search input is not active, search if content exists)
            if (e.key === 'Enter' && !isInputActive) {
                e.preventDefault(); // Prevent default browser behavior
                let query = searchInput.value.trim();
                if (query) {
                    let selectedEngine = document.querySelector('input[name="engine"]:checked').value;
                    performSearch(query, selectedEngine, false); // Regular search in current tab
                }
                return; // Exit
            }

            // Handle '/' for focusing search input (when not active)
            if (!isInputActive && key === '/') {
                e.preventDefault();
                searchInput.focus();
            }

            // Handle Escape for blurring search input (when active)
            if (e.key === 'Escape' && isInputActive) {
                searchInput.blur();
            }
        });


        // Function to initialize the app
        function initializeApp() {
            // Element reference for editGoalModal
            window.editGoalModal = document.querySelector('#edit-goal-section .edit-goal-modal');

            // Event listener for the new combined action button
            if (editGoalActionButton) {
                editGoalActionButton.addEventListener('click', handleEditGoalAction);
            }
            // Event listener for the delete button
            if (editGoalDeleteButton) {
                editGoalDeleteButton.addEventListener('click', handleDeleteGoal);
            }
            // Event listener for input changes to update action button text
            if (editGoalInput) {
                editGoalInput.addEventListener('input', updateActionButtonText);
            }

            document.addEventListener('toggle-tasks', updateLayout);

            // Also update active line on window resize to handle responsive changes
            window.addEventListener('resize', updateActiveLinePosition);

            
            setInterval(updateGoalTimeSince, 60 * 1000); // This will now conditionally render goals

            // Apply saved preferences directly
            // This ensures theme-dependent elements like active-line color and theme-toggle text are set.

            goalsEnabled = localStorage.getItem('goalsEnabled') === 'true'; // Default to false if not set
            updateLayout();
            
            
            updateActiveLineAndSections(); // Initial setup for engine selector
            
            // Ensure loading overlay is off
            blankScreenOverlay.style.opacity = '0'; 
            blankScreenOverlay.style.pointerEvents = 'none';



            setTimeout(() => {
            searchInput.focus();
                
            }, 400);
            // Focus on the search input when the app initializes


            
        }


        // Initial call when the DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // This part ensures engine-selection is moved early based on goalsEnabled
            const goalsEnabledInitial = localStorage.getItem('goalsEnabled') === 'true';
            const engineSelectionElement = document.getElementById('engine-selection');
            const topElementsContainerElement = document.getElementById('top-elements');
            const mainContentBottomContainerElement = document.getElementById('main-content-bottom');

            if (goalsEnabledInitial) {
                if (engineSelectionElement && topElementsContainerElement) {
                    topElementsContainerElement.appendChild(engineSelectionElement);
                    topElementsContainerElement.classList.add('with-engine');
                }
            } else {
                if (engineSelectionElement && mainContentBottomContainerElement) {
                    mainContentBottomContainerElement.prepend(engineSelectionElement);
                    topElementsContainerElement.classList.remove('with-engine');
                }
            }

            initializeApp(); // Call directly without delay
        });

        // Fix for blank screen on browser back button
        window.addEventListener('pageshow', (event) => {
            // Check if the page is being shown from the bfcache (back-forward cache)
            // This means the user navigated back to the page.
            if (event.persisted) {
                blankScreenOverlay.style.opacity = '0';
                blankScreenOverlay.style.pointerEvents = 'none';
            }
        });
    </script>
</body>
</html>

