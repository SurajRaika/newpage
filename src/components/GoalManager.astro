--- 
---


<div id="goal-context-menu" class="context-menu absolute bg-[rgb(var(--color-secondary-bg))] border border-[rgb(var(--color-border-color))] rounded-sm shadow-lg z-50 flex-col min-w-[120px] py-1
             dark:bg-[rgb(var(--color-secondary-bg))] dark:border-[rgb(var(--color-border-color))]">
        <div class="context-menu-item px-4 py-2 text-[rgb(var(--color-text-primary))] text-sm cursor-pointer whitespace-nowrap hover:bg-[rgb(var(--color-border-color))]
                    dark:text-[rgb(var(--color-text-primary))] dark:hover:bg-[rgb(var(--color-border-color))]" data-action="completed">Completed</div>
        <div class="context-menu-item px-4 py-2 text-[rgb(var(--color-text-primary))] text-sm cursor-pointer whitespace-nowrap hover:bg-[rgb(var(--color-border-color))]
                    dark:text-[rgb(var(--color-text-primary))] dark:hover:bg-[rgb(var(--color-border-color))]" data-action="delete">Delete</div>
</div>



<script>
        const editGoalInput = document.getElementById("edit-goal-input");

        const goalsContainer = document.getElementById("goals-container");
        const goalContextMenu = document.getElementById("goal-context-menu");

                document.addEventListener("DOMContentLoaded", () => {
                localStorage.getItem("goalsEnabled") === "true";
                     const goalsEnabledInitial =
                localStorage.getItem("goalsEnabled") === "true";
            const engineSelectionElement =
                document.getElementById("engine-selection");
            const topElementsContainerElement =
                document.getElementById("top-elements");
            const mainContentBottomContainerElement = document.getElementById(
                "main-content-bottom",
            );

               if (goalsEnabledInitial) {
                if (engineSelectionElement && topElementsContainerElement) {
                    topElementsContainerElement.appendChild(
                        engineSelectionElement,
                    );
                    topElementsContainerElement.classList.add("with-engine");
                }
            } else {
                if (
                    engineSelectionElement &&
                    mainContentBottomContainerElement
                ) {
                    mainContentBottomContainerElement.prepend(
                        engineSelectionElement,
                    );
                    topElementsContainerElement.classList.remove("with-engine");
                }
            }



            initializeComponent()
                })

                function initializeComponent() {
   // Event listener for input changes to update action button text
            if (editGoalInput) {
                editGoalInput.addEventListener("input", updateActionButtonText);




            }
        
        
                    // Event listener for input changes to update action button text
            if (editGoalInput) {
                editGoalInput.addEventListener("input", updateActionButtonText);
            }
        }


        let currentEditGoalIndex = -1;
        let isEditingNewGoal = false; // Renamed from isEditingDefaultGoal for clarity
        let originalGoalText = "";

        // Add Enter key listener for the goal input
        editGoalInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault(); // Prevent default form submission or new line
                handleEditGoalAction();
            }
        });

        function hideEditGoalPopup() {
            editGoalSection.classList.remove("show");
            currentEditGoalIndex = -1;
            isEditingNewGoal = false;
            originalGoalText = "";
        }

        function updateActionButtonText() {
            if (editGoalInput.value.trim() !== originalGoalText.trim()) {
                editGoalActionButton.textContent = "Save";
            } else {
                editGoalActionButton.textContent = "Completed";
            }
        }

        function handleEditGoalAction() {
            if (editGoalActionButton.textContent === "Save") {
                handleSaveGoal();
            } else if (editGoalActionButton.textContent === "Completed") {
                handleCompleteGoal();
            }
        }
        window.handleEditGoalAction=handleEditGoalAction()


        
    // Add Enter key listener for the goal input
        editGoalInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault(); // Prevent default form submission or new line
                handleEditGoalAction();
            }
        });
        
        function handleSaveGoal() {
            const newText = editGoalInput.value.trim();
            if (!newText) {
                console.warn("Goal title cannot be empty.");
                return;
            }

            let userGoals = getGoals(); // Get all current goals

            if (isEditingNewGoal) {
                // If it was a new goal being added
                userGoals.push({
                    text: newText,
                    creationTime: new Date().toISOString(),
                });
            } else {
                // If an existing user goal was edited, update it
                if (
                    currentEditGoalIndex !== -1 &&
                    currentEditGoalIndex < userGoals.length
                ) {
                    userGoals[currentEditGoalIndex].text = newText;
                }
            }
            saveGoals(userGoals);
            renderGoals();
            hideEditGoalPopup();
        }

        function handleCompleteGoal() {
            if (isEditingNewGoal) {
                // If it's the "add goal" prompt, just close
                hideEditGoalPopup();
                return;
            }

            let userGoals = getGoals();
            if (
                currentEditGoalIndex !== -1 &&
                currentEditGoalIndex < userGoals.length
            ) {
                userGoals.splice(currentEditGoalIndex, 1);
                saveGoals(userGoals);
                renderGoals();
            }
            hideEditGoalPopup();
        }

        function handleDeleteGoal() {
            if (isEditingNewGoal) {
                // If it's the "add goal" prompt, just close
                hideEditGoalPopup();
                return;
            }

            let userGoals = getGoals();
            if (
                currentEditGoalIndex !== -1 &&
                currentEditGoalIndex < userGoals.length
            ) {
                userGoals.splice(currentEditGoalIndex, 1);
                saveGoals(userGoals);
                renderGoals();
            }
            hideGoalContextMenu(); // Ensure context menu is hidden
            hideEditGoalPopup(); // Ensure edit popup is hidden
        }

        function showGoalContextMenu(e, index, isNewGoal = false) {
            // Renamed isDefault to isNewGoal
            e.preventDefault();
            if (isNewGoal) return; // Right-click does nothing on the "add goal" prompt

            const currentGoals = getGoals();
            if (index < 0 || index >= currentGoals.length) return;

            goalContextMenu.classList.add("show");
            goalContextMenu.style.left = `${e.clientX}px`;
            goalContextMenu.style.top = `${e.clientY}px`;
            goalContextMenu.dataset.goalIndex = index;
            // Set visibility immediately for context menu
            goalContextMenu.style.visibility = "visible";
            goalContextMenu.style.pointerEvents = "auto";
        }

        function hideGoalContextMenu() {
            goalContextMenu.classList.remove("show");
            goalContextMenu.removeAttribute("data-goal-index");
            // Use a timeout to hide visibility after transition completes
            setTimeout(() => {
                goalContextMenu.style.visibility = "hidden";
                goalContextMenu.style.pointerEvents = "none";
            }, 200); // Match transition-duration of opacity/transform
        }
 function getGoals() {
    try {
        const goalsString = localStorage.getItem("userGoals");
        return goalsString ? JSON.parse(goalsString) : [];
    } catch (e) {
        console.error("Error parsing goals from localStorage:", e);
        return [];
    }
}
        
function renderGoals() {
            const userGoals = getGoals(); // Get only user-defined goals

            goalsContainer.innerHTML = ''; // Clear existing goals/button

            const maxVisibleSlots = 2; // Always aim for 2 slots

            for (let i = 0; i < maxVisibleSlots; i++) {
                if (userGoals[i]) {
                    // Render existing user goal
                    const goalItem = document.createElement('div');
                    goalItem.className = 'goal-item flex flex-row items-center gap-2 py-1 border rounded-sm text-xs font-medium min-h-[2.2rem] box-border whitespace-nowrap overflow-hidden text-ellipsis cursor-pointer justify-start relative hover:border-[rgb(var(--color-accent))] hover:bg-[rgb(var(--color-secondary-bg))] hover:text-[rgb(var(--color-text-primary))] ' +
                                        'border-[rgb(var(--color-border-color))] text-[rgb(var(--color-text-primary))] '; /* Apply unified styling */
                    goalItem.dataset.index = i;
                    goalItem.innerHTML = `
                        <i class="ph-fill ph-clipboard-text goal-icon text-base flex-shrink-0 ml-2 group-hover:text-[rgb(var(--color-text-primary))] ' +
                                        'text-[rgb(var(--color-text-secondary))]"></i>
                        <span class="goal-title text-xs font-medium whitespace-nowrap overflow-hidden text-ellipsis flex-grow ' +
                                        'text-[rgb(var(--color-text-primary))]">${userGoals[i].text}</span>
                        <span class="time-since text-[0.7rem] font-normal whitespace-nowrap ml-auto flex-shrink-0 mr-2 ' +
                                        'text-[rgb(var(--color-text-secondary))]">${userGoals[i].creationTime ? formatTimeAgo(userGoals[i].creationTime) : ''}</span>
                    `;
                    goalItem.addEventListener('click', (e) => {
                        showEditGoalPopup(e, i, false);
                    });
                    goalItem.addEventListener('contextmenu', (e) => showGoalContextMenu(e, i, false));
                    goalsContainer.appendChild(goalItem);
                } else {
                    // Render "Click here to add goal" card
                    const setupPrompt = document.createElement('div');
                    setupPrompt.className = 'add-goal-prompt flex flex-row items-center gap-2 py-1 border border-dashed rounded-sm text-xs font-medium min-h-[2.2rem] box-border whitespace-nowrap overflow-hidden text-ellipsis cursor-pointer justify-start relative hover:border-[rgb(var(--color-accent))] hover:bg-[rgb(var(--color-secondary-bg))] hover:text-[rgb(var(--color-text-primary))] ' +
                                            'border-[rgb(var(--color-border-color))] text-[rgb(var(--color-text-secondary))] '; /* Apply unified styling */
                    setupPrompt.innerHTML = `
                        <i class="ph-fill ph-clipboard-text goal-icon text-base flex-shrink-0 ml-2 group-hover:text-[rgb(var(--color-text-primary))] ' +
                                        'text-[rgb(var(--color-text-secondary))]"></i>
                        <span>Click here to add your next goal</span>
                    `;
                    setupPrompt.addEventListener('click', (e) => {
                        showEditGoalPopup(e, -1, true); // isNewGoal true for new goal
                    });
                    goalsContainer.appendChild(setupPrompt);
                }
            }
        }


        
function saveGoals(goalsArray) {
    try {
        localStorage.setItem("userGoals", JSON.stringify(goalsArray));
    } catch (e) {
        console.error("Error saving goals to localStorage:", e);
    }
}



   function showEditGoalPopup(e, index, isNewGoal = false) {
            // Renamed isDefault to isNewGoal
            e.stopPropagation();
            currentEditGoalIndex = index;
            isEditingNewGoal = isNewGoal;

            let goalText = "";
            if (!isNewGoal) {
                // If it's an existing goal
                const currentGoals = getGoals();
                const goalToEdit = currentGoals[index];
                goalText = goalToEdit ? goalToEdit.text : "";
            }
            // If isNewGoal is true (clicked "add goal" prompt), goalText remains empty, which is correct for new goal.

            originalGoalText = goalText;
            editGoalInput.value = goalText;
            editGoalSection.classList.add("show");
            editGoalInput.focus();

            updateActionButtonText();
        }


        renderGoals()
</script>