<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minimal Search</title>   
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <!-- Phosphor Icons CDN for filled icons -->
    <script src="https://unpkg.com/@phosphor-icons/web@2.1.1/dist/phosphor.js"></script>
    <!-- Tailwind CSS CDN with custom config to match existing colors -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class', // Enable dark mode based on 'dark' class on html element
            theme: {
                extend: {
                    colors: {
                        // Default (Light) Mode Colors
                        'primary-bg': '#f0f0f0',
                        'secondary-bg': '#e0e0e0',
                        'border-color': '#bbbbbb',
                        'text-primary': '#1a1a1a',
                        'text-secondary': '#444444',
                        'text-placeholder': '#777777',
                        'accent': '#888888', // Light mode accent/focus
                        'radio-selected-bg': '#dddddd',
                        'radio-selected-dot': '#1a1a1a',

                        // Dark Mode Overrides (used with dark: prefix)
                        dark: {
                            'primary-bg': '#1a1a1a',
                            'secondary-bg': '#2a2a2a',
                            'border-color': '#444444',
                            'text-primary': '#f0f0f0',
                            'text-secondary': '#cccccc',
                            'text-placeholder': '#888888',
                            'accent': '#ffffff', // Dark mode accent/focus
                            'radio-selected-bg': '#555555',
                            'radio-selected-dot': '#ffffff',
                        },
                    },
                    transitionProperty: {
                        'all': 'all',
                    },
                    transitionTimingFunction: {
                        'ease-out': 'ease-out',
                    },
                    transitionDuration: {
                        '200': '0.2s',
                        '300': '0.3s',
                        '400': '0.4s',
                        '50': '0.05s',
                    },
                    animation: {
                        'slide-fade': 'slide-fade 1s infinite cubic-bezier(0.65, 0.05, 0.36, 1)',
                    },
                    keyframes: {
                        'slide-fade': {
                            '0%': { opacity: '0', transform: 'translateX(-50px)' },
                            '25%': { opacity: '1', transform: 'translateX(0)' },
                            '75%': { opacity: '1', transform: 'translateX(50px)' },
                            '100%': { opacity: '0', transform: 'translateX(100px)' },
                        }
                    }
                }
            }
        }
    </script>
    <style type="text/css">
        /* Global transition for all elements for smoother UI */
        * {
            transition-property: all;
            transition-timing-function: ease-out;
            transition-duration: 0.2s;
        }

        /* Specific styles not easily replaced by Tailwind without breaking design */
        /* Active line indicator - now a single element */
        #active-line {
            position: absolute;
            bottom: 0;
            height: 2px;
            /* Background color set by JS based on theme */
            border-radius: 1px;
            transition: left 0.3s ease-out, width 0.3s ease-out; /* Sliding animation */
            z-index: 10; /* Ensure it's on top */
        }

        /* Hide the actual radio button visually */
        .custom-radio {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        /* Webkit browsers (Chrome, Safari) scrollbar styles */
        .history-list::-webkit-scrollbar {
            width: 6px; /* width of the scrollbar */
        }

        .history-list::-webkit-scrollbar-track {
            background: transparent; /* color of the tracking area */
        }

        .history-list::-webkit-scrollbar-thumb {
            background-color: #bbbbbb; /* Light mode thumb color */
            border-radius: 10px; /* roundness of the scroll thumb */
            border: 1px solid #e0e0e0; /* Light mode border color */
        }

        /* Dark mode scrollbar thumb */
        html.dark .history-list::-webkit-scrollbar-thumb {
            background-color: #444444; /* Dark mode thumb color */
            border: 1px solid #2a2a2a; /* Dark mode border color */
        }

        /* Firefox scrollbar styles */
        .history-list {
            scrollbar-width: thin;
            scrollbar-color: #bbbbbb transparent; /* Light mode thumb and track color */
        }

        /* Dark mode Firefox scrollbar */
        html.dark .history-list {
            scrollbar-color: #444444 transparent; /* Dark mode thumb and track color */
        }

        /* More Menu specific styles for visibility transition */
        #more-menu {
            display: flex; /* Keep flex display always */
            visibility: hidden; /* Start hidden for transitions */
            opacity: 0;
            transform: translateY(10px);
            pointer-events: none; /* Prevent clicks when hidden */
            transition: opacity 0.2s ease-out, transform 0.2s ease-out, visibility 0.2s ease-out;
        }

        #more-menu.show {
            visibility: visible;
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto; /* Allow clicks when shown */
        }

        /* Goal Context Menu specific styles for visibility transition */
        #goal-context-menu {
            display: flex; /* Keep flex display always */
            visibility: hidden; /* Start hidden for transitions */
            opacity: 0;
            pointer-events: none; /* Prevent clicks when hidden */
            transition: opacity 0.2s ease-out, visibility 0.2s ease-out;
        }

        #goal-context-menu.show {
            visibility: visible;
            opacity: 1;
            pointer-events: auto;
        }

        /* Edit Goal Section (Modal Overlay) specific styles for visibility transition */
        #edit-goal-section {
            transition: opacity 0.15s ease-out; /* Fast fade for overlay */
        }
        #edit-goal-section.show {
            opacity: 1;
            pointer-events: auto;
        }
        /* Modal inside edit goal section for slide effect */
        #edit-goal-section .edit-goal-modal {
            transform: translateY(-100%); /* Start completely off-screen top */
            transition: transform 0.15s ease-out; /* Fast slide */
        }
        #edit-goal-section.show .edit-goal-modal {
            transform: translateY(0); /* Slide into view */
        }


        /* Search History Section visibility and transition */
        #search-history-section {
            transition: max-height 0.15s ease-out, opacity 0.15s ease-out; /* Fast expand/collapse and fade */
        }
        #search-history-section.show {
            max-height: 500px; /* Sufficient height to show content */
            opacity: 1;
        }

        /* When engine-selection is at the top, ensure flex-item behavior */
        #top-elements.with-engine #time-info {
            flex-shrink: 0;
            flex-grow: 0;
        }
        #top-elements.with-engine #engine-selection {
            flex-shrink: 0;
            flex-grow: 0;
        }
    </style>
    <!-- Inline script to prevent theme flicker -->
    <script>
        (function() {
            const themePreference = localStorage.getItem('themePreference');
            if (themePreference === 'dark') {
                document.documentElement.classList.add('dark');
            } else {
                // Default to light mode if no preference or preference is 'light'
                document.documentElement.classList.remove('dark');
            }
        })();
    </script>
</head>
<body class="font-inter bg-primary-bg text-text-primary flex items-center justify-center min-h-screen p-4 antialiased
             dark:bg-dark-primary-bg dark:text-dark-text-primary">
    <!-- Blank screen overlay for transition -->
    <div id="blank-screen-overlay" class="fixed inset-0 opacity-0 pointer-events-none z-[9999] transition-opacity duration-50 flex items-center justify-center
             bg-primary-bg dark:bg-dark-primary-bg">
        <div id="loading-indicator" class="w-[50px] h-1 bg-accent rounded-sm opacity-0 animate-slide-fade dark:bg-dark-accent"></div>
    </div>

    <!-- Goal Context Menu (Right-click) -->
    <div id="goal-context-menu" class="context-menu absolute bg-secondary-bg border border-border-color rounded-sm shadow-lg z-50 flex-col min-w-[120px] py-1
             dark:bg-dark-secondary-bg dark:border-dark-border-color">
        <div class="context-menu-item px-4 py-2 text-text-primary text-sm cursor-pointer whitespace-nowrap hover:bg-border-color
                    dark:text-dark-text-primary dark:hover:bg-dark-border-color" data-action="completed">Completed</div>
        <div class="context-menu-item px-4 py-2 text-text-primary text-sm cursor-pointer whitespace-nowrap hover:bg-border-color
                    dark:text-dark-text-primary dark:hover:bg-dark-border-color" data-action="delete">Delete</div>
    </div>

    <div class="container-wrapper w-full max-w-xl flex flex-col gap-4 relative">
        <!-- New Edit Goal Section - For single goal edit, appears from top -->
        <div id="edit-goal-section" class="fixed inset-0 bg-black bg-opacity-30 flex justify-center items-start z-[10000] opacity-0 pointer-events-none">
            <div class="edit-goal-modal bg-secondary-bg border border-border-color rounded-sm p-2 flex flex-row items-center gap-2 w-[90%] max-w-xl shadow-none mt-4 focus-within:border-accent focus-within:shadow-md
                        dark:bg-dark-secondary-bg dark:border-dark-border-color dark:focus-within:border-dark-accent">
                <label for="edit-goal-input" class="text-text-secondary text-sm flex flex-col gap-1 flex-grow
                                            dark:text-dark-text-secondary">
                    <input type="text" id="edit-goal-input" placeholder="Edit your goal title" class="bg-primary-bg border border-border-color rounded-sm px-2 py-1.5 text-text-primary text-base w-full box-border focus:outline-none focus:border-accent
                                            dark:bg-dark-primary-bg dark:border-dark-border-color dark:text-dark-text-primary dark:focus:border-dark-accent">
                </label>
                <div class="button-group flex flex-row gap-1 items-center ml-auto">
                    <button id="edit-goal-action-button" class="bg-accent text-primary-bg px-2.5 py-1.5 border-none rounded-sm cursor-pointer font-semibold text-xs transition-colors duration-200 hover:bg-text-secondary
                                            dark:bg-dark-accent dark:text-dark-primary-bg dark:hover:bg-dark-text-secondary"></button> <!-- This will be Save or Completed -->
                    <button id="edit-goal-delete-button" class="delete-button bg-border-color text-text-primary px-2.5 py-1.5 border-none rounded-sm cursor-pointer font-semibold text-xs transition-colors duration-200 hover:bg-red-500 hover:text-white
                                            dark:bg-dark-border-color dark:text-dark-text-primary">Delete</button>
                </div>
            </div>
        </div>

        <!-- Top elements: Time Info and dynamically moved Engine Selection -->
        <div id="top-elements" class="flex flex-col gap-4 items-start w-full">
            <div id="time-info" class="time-info flex items-center gap-2 text-text-secondary text-sm font-medium whitespace-nowrap
                                dark:text-dark-text-secondary">
                <!-- Phosphor Icon element -->
                <i id="time-icon" class="ph w-6 h-6 flex items-center justify-center rounded-full bg-accent text-primary-bg
                                   dark:bg-dark-accent dark:text-dark-primary-bg"></i>
                <span id="current-time" class="current-time text-xs font-semibold text-text-primary
                                       dark:text-dark-text-primary"></span>
            </div>
            <!-- The engine-selection element will be dynamically moved here or in main-content-bottom -->
        </div>

        <div class="search-area-wrapper flex flex-col bg-secondary-bg border-2 border-border-color rounded-sm p-1 relative focus-within:border-accent
                    dark:bg-dark-secondary-bg dark:border-dark-border-color dark:focus-within:border-dark-accent">
            <form id="search-form" class="search-form w-full flex-grow mt-0">
                <div class="input-wrapper relative flex items-center w-full">
                    <input
                        type="text"
                        id="search-input"
                        name="query"
                        class="search-input w-full bg-transparent border-none rounded-none pt-1.5 pb-1.5 pl-2 pr-10 text-text-primary text-base leading-relaxed placeholder:text-text-placeholder focus:outline-none
                                dark:text-dark-text-primary dark:placeholder:text-dark-text-placeholder"
                        placeholder="Search the web..."
                        autocomplete="off"
                    />
                    <button type="submit" class="search-button absolute right-0 mr-2 text-text-secondary cursor-pointer bg-none border-none p-0 flex items-center justify-center hover:text-text-primary
                                dark:text-dark-text-secondary dark:hover:text-dark-text-primary" aria-label="Search">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="search-icon w-5 h-5">
                            <path d="m21 21-4.35-4.35m0 0A7.5 7.5 0 1 0 6.5 6.5a7.5 7.5 0 0 0 10.2 10.2Z"/>
                        </svg>
                    </button>
                </div>
            </form>
        </div>

        <!-- Main content bottom: Engine Selection (if goals hidden), Goals, Daily Progress -->
        <div id="main-content-bottom" class="flex gap-4 w-full flex-row justify-between items-center">
            <div id="engine-selection" class="engine-selection flex flex-row flex-wrap items-start gap-3 pl-1 relative">
                <label class="engine-label flex flex-col items-center gap-1 cursor-pointer relative py-0.5 min-w-[4rem]" title="Switch to Google search (G)">
                    <input type="radio" name="engine" value="google" class="custom-radio" checked>
                    <span class="radio-text font-medium text-text-secondary whitespace-nowrap uppercase text-xs px-0.5 hover:text-text-primary
                                dark:text-dark-text-secondary dark:hover:text-dark-text-primary">Google</span>
                </label>
                <label class="engine-label flex flex-col items-center gap-1 cursor-pointer relative py-0.5 min-w-[4rem]" title="Switch to Perplexity search (P)">
                    <input type="radio" name="engine" value="perplexity" class="custom-radio">
                    <span class="radio-text font-medium text-text-secondary whitespace-nowrap uppercase text-xs px-0.5 hover:text-text-primary
                                dark:text-dark-text-secondary dark:hover:text-dark-text-primary">Perplexity</span>
                </label>
                <label class="engine-label flex flex-col items-center gap-1 cursor-pointer relative py-0.5 min-w-[4rem]" title="Switch to YouTube search (Y)">
                    <input type="radio" name="engine" value="youtube" class="custom-radio">
                    <span class="radio-text font-medium text-text-secondary whitespace-nowrap uppercase text-xs px-0.5 hover:text-text-primary
                                dark:text-dark-text-secondary dark:hover:text-dark-text-primary">YouTube</span>
                </label>
                <label class="engine-label flex flex-col items-center gap-1 cursor-pointer relative py-0.5 min-w-[4rem]" title="Switch to ChatGPT search (C)">
                    <input type="radio" name="engine" value="chatgpt" class="custom-radio">
                    <span class="radio-text font-medium text-text-secondary whitespace-nowrap uppercase text-xs px-0.5 hover:text-text-primary
                                dark:text-dark-text-secondary dark:hover:text-dark-text-primary">ChatGPT</span>
                </label>
                <label class="engine-label flex flex-col items-center gap-1 cursor-pointer relative py-0.5 min-w-[4rem]" title="View search history (H)">
                    <input type="radio" name="engine" value="history" class="custom-radio">
                    <span class="radio-text font-medium text-text-secondary whitespace-nowrap uppercase text-xs px-0.5 hover:text-text-primary
                                dark:text-dark-text-secondary dark:hover:text-dark-text-primary">History</span>
                </label>
                <div id="active-line"></div> <!-- Single active line for sliding effect -->
            </div>

            <div class="goals-container w-full flex-grow max-w-none pr-0 grid grid-cols-2 gap-4 items-start" id="goals-container">
                <!-- Goals or "Click here to set up" message will be rendered here -->
            </div>
            <div class="daily-progress-container flex flex-col gap-2 w-full pl-1 sm:w-auto sm:pl-0">
                <div class="progress-label text-xs font-medium text-text-secondary uppercase whitespace-nowrap
                            dark:text-dark-text-secondary">DAY REMAINing: <span id="day-remaining-percent"></span>%</div>
                <div class="progress-bar-wrapper bg-border-color rounded-sm h-2 w-full overflow-hidden
                            dark:bg-dark-border-color">
                    <div id="day-progress-bar" class="progress-bar bg-accent h-full w-0 rounded-sm
                                dark:bg-dark-accent"></div>
                </div>
            </div>
        </div>

        <!-- New Search History Section -->
        <div id="search-history-section" class="history-section flex flex-col gap-3 bg-transparent border-t-2 border-accent rounded-none pt-4 pl-1 pr-1 pb-2 overflow-hidden max-h-0 opacity-0 transition-all duration-300 box-border mt-4
                    dark:border-dark-accent">
            <div class="history-header flex justify-between items-center pb-2 border-b border-border-color mb-2
                        dark:border-dark-border-color">
                <span class="history-title text-sm font-semibold text-text-primary uppercase
                            dark:text-dark-text-primary">Search History</span>
                <button id="clear-history-button" class="clear-history-button bg-none border border-border-color text-text-secondary px-3 py-1 rounded-sm cursor-pointer text-xs transition-all duration-200 hover:bg-border-color hover:text-text-primary
                            dark:border-dark-border-color dark:text-dark-text-secondary dark:hover:bg-dark-border-color dark:hover:text-dark-text-primary">Clear All</button>
            </div>
            <ul id="history-list" class="history-list list-none p-0 m-0 max-h-[calc(20rem-3rem)] overflow-y-auto">
                <!-- History items will be dynamically added here by JavaScript -->
            </ul>
        </div>
    </div>

    <!-- More Button and Menu -->
    <button id="more-button" class="fixed bottom-4 right-4 bg-secondary-bg text-text-primary border border-border-color px-4 py-2 rounded-md cursor-pointer text-sm font-medium z-[10001] transition-all duration-200 whitespace-nowrap hover:bg-border-color hover:text-accent
                dark:bg-dark-secondary-bg dark:text-dark-text-primary dark:border-dark-border-color dark:hover:bg-dark-border-color dark:hover:text-dark-accent">More</button>
    <div id="more-menu" class="fixed bottom-[calc(1rem+2.5rem+0.5rem)] right-4 bg-secondary-bg border border-border-color rounded-md invisible flex-col p-2 gap-2 z-[10000] shadow-lg opacity-0 translate-y-2 transition-all duration-200
                dark:bg-dark-secondary-bg dark:border-dark-border-color">
        <button id="theme-toggle" class="menu-item bg-transparent text-text-primary border border-transparent px-3 py-1.5 rounded-sm cursor-pointer text-sm font-medium text-left whitespace-nowrap transition-all duration-150 hover:bg-border-color hover:text-accent
                    dark:text-dark-text-primary dark:hover:bg-dark-border-color dark:hover:text-dark-accent"></button>
        <button id="tasks-toggle" class="menu-item bg-transparent text-text-primary border border-transparent px-3 py-1.5 rounded-sm cursor-pointer text-sm font-medium text-left whitespace-nowrap transition-all duration-150 hover:bg-border-color hover:text-accent
                    dark:text-dark-text-primary dark:hover:bg-dark-border-color dark:hover:text-dark-accent"></button>
    </div>

    <script>
        // --- Function Definitions (All moved to top for scope) ---

        // CDN-hosted Phosphor Icons (filled variant) - Defined early as it's a constant
        const timeOfDayIconClasses = {
            morning: 'ph-fill ph-sunrise',
            m_day: 'ph-fill ph-sun',
            evening: 'ph-fill ph-sunset',
            night: 'ph-fill ph-moon',
        };

        const searchEnginePlaceholders = {
            google: "Search Google...",
            perplexity: "Search Perplexity...",
            youtube: "Search YouTube...",
            chatgpt: "Search ChatGPT...",
            history: "View search history or search Google..." // Special case for history
        };

        function updateTimeOfDayInfo() {
            const now = new Date();
            const hour = now.getHours();
            let iconClass;
            let timeOfDayText;

            if (hour >= 5 && hour < 12) {
                iconClass = timeOfDayIconClasses.morning;
                timeOfDayText = 'Morning';
            } else if (hour >= 12 && hour < 18) {
                iconClass = timeOfDayIconClasses.m_day;
                timeOfDayText = 'Day';
            } else if (hour >= 18 && hour < 21) {
                iconClass = timeOfDayIconClasses.evening;
                timeOfDayText = 'Evening';
            } else {
                iconClass = timeOfDayIconClasses.night;
                timeOfDayText = 'Night';
            }

            // Options for date and time formatting
            const dateOptions = { weekday: 'short', month: 'short', day: 'numeric' };
            const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: true };

            const formattedDate = now.toLocaleDateString('en-US', dateOptions);
            const formattedTime = now.toLocaleTimeString('en-US', timeOptions);

            if (timeIconElement && currentTimeSpan) {
                timeIconElement.className = 'ph ' + iconClass;
                // Combine date, time, and time of day text
                currentTimeSpan.textContent = `${formattedDate}, ${formattedTime} (${timeOfDayText})`;
            }
        }

        function updateProgressBar(type, percent) {
            let progressBar;
            let percentText;

            if (type === 'day') {
                progressBar = document.getElementById('day-progress-bar');
                percentText = document.getElementById('day-remaining-percent');
            }

            if (progressBar && percentText) {
                const clampedPercent = Math.max(0, Math.min(100, percent));
                progressBar.style.width = `${clampedPercent}%`;
                percentText.textContent = clampedPercent.toFixed(1); // Display with one decimal place
            }
        }

        function updateDayProgress() {
            const now = new Date();
            const currentYear = now.getFullYear();
            const currentMonth = now.getMonth();
            const currentDay = now.getDate();

            // Use stored wake/sleep times or fall back to defaults
            const wakeTime = localStorage.getItem('wakeTime') || '06:00';
            const sleepTime = localStorage.getItem('sleepTime') || '22:00';

            const [wakeHour, wakeMinute] = wakeTime.split(':').map(Number);
            const [sleepHour, sleepMinute] = sleepTime.split(':').map(Number);

            const startOfActiveDay = new Date(currentYear, currentMonth, currentDay, wakeHour, wakeMinute, 0);
            const endOfActiveDay = new Date(currentYear, currentMonth, currentDay, sleepHour, sleepMinute, 0);

            // Handle cases where sleep time might be on the next day (e.g., wake 6 AM, sleep 2 AM next day)
            if (sleepHour < wakeHour) {
                endOfActiveDay.setDate(endOfActiveDay.getDate() + 1);
            }

            if (now < startOfActiveDay) {
                updateProgressBar('day', 100); // Before active day, show 100% remaining
                return;
            }

            if (now > endOfActiveDay) {
                updateProgressBar('day', 0); // After active day, show 0% remaining
                return;
            }

            const totalMillisecondsInActiveDay = endOfActiveDay.getTime() - startOfActiveDay.getTime();
            const elapsedMillisecondsInActiveDay = now.getTime() - startOfActiveDay.getTime();

            const elapsedPercent = (elapsedMillisecondsInActiveDay / totalMillisecondsInActiveDay) * 100;
            const remainingPercent = 100 - elapsedPercent;

            updateProgressBar('day', remainingPercent);
        }

        function formatTimeAgo(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const seconds = Math.floor((now - date) / 1000);

            if (seconds < 60) return `${seconds}s ago`;
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            if (days < 30) return `${days}d ago`;
            const months = Math.floor(days / 30.44);
            if (months < 12) return `${months}mo ago`;
            const years = Math.floor(months / 12);
            return `${years}y ago`;
        }

        function getGoals() {
            try {
                const goalsString = localStorage.getItem('userGoals');
                return goalsString ? JSON.parse(goalsString) : [];
            } catch (e) {
                console.error("Error parsing goals from localStorage:", e);
                return [];
            }
        }

        function saveGoals(goalsArray) {
            try {
                localStorage.setItem('userGoals', JSON.stringify(goalsArray));
            } catch (e) {
                console.error("Error saving goals to localStorage:", e);
            }
        }

        function renderGoals() {
            const userGoals = getGoals(); // Get only user-defined goals

            goalsContainer.innerHTML = ''; // Clear existing goals/button

            const maxVisibleSlots = 2; // Always aim for 2 slots

            for (let i = 0; i < maxVisibleSlots; i++) {
                if (userGoals[i]) {
                    // Render existing user goal
                    const goalItem = document.createElement('div');
                    goalItem.className = 'goal-item flex flex-row items-center gap-2 py-1 border rounded-sm text-xs font-medium min-h-[2.2rem] box-border whitespace-nowrap overflow-hidden text-ellipsis cursor-pointer justify-start relative hover:border-accent hover:bg-secondary-bg hover:text-text-primary ' +
                                        'border-border-color text-text-primary ' +
                                        'dark:border-dark-border-color dark:hover:border-dark-accent dark:hover:bg-dark-secondary-bg dark:hover:text-dark-text-primary'; /* Apply unified styling */
                    goalItem.dataset.index = i;
                    goalItem.innerHTML = `
                        <i class="ph-fill ph-clipboard-text goal-icon text-base flex-shrink-0 ml-2 group-hover:text-text-primary ' +
                                        'text-text-secondary dark:text-dark-text-secondary dark:group-hover:text-dark-text-primary"></i>
                        <span class="goal-title text-xs font-medium whitespace-nowrap overflow-hidden text-ellipsis flex-grow ' +
                                        'text-text-primary dark:text-dark-text-primary">${userGoals[i].text}</span>
                        <span class="time-since text-[0.7rem] font-normal whitespace-nowrap ml-auto flex-shrink-0 mr-2 ' +
                                        'text-text-secondary dark:text-dark-text-secondary">${userGoals[i].creationTime ? formatTimeAgo(userGoals[i].creationTime) : ''}</span>
                    `;
                    goalItem.addEventListener('click', (e) => {
                        showEditGoalPopup(e, i, false);
                    });
                    goalItem.addEventListener('contextmenu', (e) => showGoalContextMenu(e, i, false));
                    goalsContainer.appendChild(goalItem);
                } else {
                    // Render "Click here to add goal" card
                    const setupPrompt = document.createElement('div');
                    setupPrompt.className = 'add-goal-prompt flex flex-row items-center gap-2 py-1 border border-dashed rounded-sm text-xs font-medium min-h-[2.2rem] box-border whitespace-nowrap overflow-hidden text-ellipsis cursor-pointer justify-start relative hover:border-accent hover:bg-secondary-bg hover:text-text-primary ' +
                                            'border-border-color text-text-secondary ' +
                                            'dark:border-dark-border-color dark:hover:border-dark-accent dark:hover:bg-dark-secondary-bg dark:hover:text-dark-text-primary'; /* Apply unified styling */
                    setupPrompt.innerHTML = `
                        <i class="ph-fill ph-clipboard-text goal-icon text-base flex-shrink-0 ml-2 group-hover:text-text-primary ' +
                                        'text-text-secondary dark:text-dark-text-secondary dark:group-hover:text-dark-text-primary"></i>
                        <span>Click here to add your next goal</span>
                    `;
                    setupPrompt.addEventListener('click', (e) => {
                        showEditGoalPopup(e, -1, true); // isNewGoal true for new goal
                    });
                    goalsContainer.appendChild(setupPrompt);
                }
            }
        }

        let currentEditGoalIndex = -1;
        let isEditingNewGoal = false; // Renamed from isEditingDefaultGoal for clarity
        let originalGoalText = '';

        function showEditGoalPopup(e, index, isNewGoal = false) { // Renamed isDefault to isNewGoal
            e.stopPropagation();
            currentEditGoalIndex = index;
            isEditingNewGoal = isNewGoal;

            let goalText = '';
            if (!isNewGoal) { // If it's an existing goal
                const currentGoals = getGoals();
                const goalToEdit = currentGoals[index];
                goalText = goalToEdit ? goalToEdit.text : '';
            }
            // If isNewGoal is true (clicked "add goal" prompt), goalText remains empty, which is correct for new goal.

            originalGoalText = goalText;
            editGoalInput.value = goalText;
            editGoalSection.classList.add('show');
            editGoalInput.focus();

            updateActionButtonText();
        }

        function hideEditGoalPopup() {
            editGoalSection.classList.remove('show');
            currentEditGoalIndex = -1;
            isEditingNewGoal = false;
            originalGoalText = '';
        }

        function updateActionButtonText() {
            if (editGoalInput.value.trim() !== originalGoalText.trim()) {
                editGoalActionButton.textContent = "Save";
            } else {
                editGoalActionButton.textContent = "Completed";
            }
        }

        function handleEditGoalAction() {
            if (editGoalActionButton.textContent === "Save") {
                handleSaveGoal();
            } else if (editGoalActionButton.textContent === "Completed") {
                handleCompleteGoal();
            }
        }

        function handleSaveGoal() {
            const newText = editGoalInput.value.trim();
            if (!newText) {
                console.warn("Goal title cannot be empty.");
                return;
            }

            let userGoals = getGoals(); // Get all current goals

            if (isEditingNewGoal) {
                // If it was a new goal being added
                userGoals.push({ text: newText, creationTime: new Date().toISOString() });
            } else {
                // If an existing user goal was edited, update it
                if (currentEditGoalIndex !== -1 && currentEditGoalIndex < userGoals.length) {
                    userGoals[currentEditGoalIndex].text = newText;
                }
            }
            saveGoals(userGoals);
            renderGoals();
            hideEditGoalPopup();
        }

        function handleCompleteGoal() {
            if (isEditingNewGoal) { // If it's the "add goal" prompt, just close
                hideEditGoalPopup();
                return;
            }

            let userGoals = getGoals();
            if (currentEditGoalIndex !== -1 && currentEditGoalIndex < userGoals.length) {
                userGoals.splice(currentEditGoalIndex, 1);
                saveGoals(userGoals);
                renderGoals();
            }
            hideEditGoalPopup();
        }

        function handleDeleteGoal() {
            if (isEditingNewGoal) { // If it's the "add goal" prompt, just close
                hideEditGoalPopup();
                return;
            }

            let userGoals = getGoals();
            if (currentEditGoalIndex !== -1 && currentEditGoalIndex < userGoals.length) {
                userGoals.splice(currentEditGoalIndex, 1);
                saveGoals(userGoals);
                renderGoals();
            }
            hideGoalContextMenu(); // Ensure context menu is hidden
            hideEditGoalPopup(); // Ensure edit popup is hidden
        }


        function showGoalContextMenu(e, index, isNewGoal = false) { // Renamed isDefault to isNewGoal
            e.preventDefault();
            if (isNewGoal) return; // Right-click does nothing on the "add goal" prompt

            const currentGoals = getGoals();
            if (index < 0 || index >= currentGoals.length) return;

            goalContextMenu.classList.add('show');
            goalContextMenu.style.left = `${e.clientX}px`;
            goalContextMenu.style.top = `${e.clientY}px`;
            goalContextMenu.dataset.goalIndex = index;
            // Set visibility immediately for context menu
            goalContextMenu.style.visibility = 'visible';
            goalContextMenu.style.pointerEvents = 'auto';
        }

        function hideGoalContextMenu() {
            goalContextMenu.classList.remove('show');
            goalContextMenu.removeAttribute('data-goal-index');
            // Use a timeout to hide visibility after transition completes
            setTimeout(() => {
                goalContextMenu.style.visibility = 'hidden';
                goalContextMenu.style.pointerEvents = 'none';
            }, 200); // Match transition-duration of opacity/transform
        }

        function handleContextMenuAction(action) {
            const index = parseInt(goalContextMenu.dataset.goalIndex, 10);
            if (isNaN(index)) return;

            let userGoals = getGoals();
            if (index >= 0 && index < userGoals.length) {
                if (action === 'completed' || action === 'delete') {
                    userGoals.splice(index, 1);
                    saveGoals(userGoals);
                    renderGoals();
                }
            }
            hideGoalContextMenu();
        }

        function getSearchHistory() {
            try {
                const history = localStorage.getItem('searchHistory');
                return history ? JSON.parse(history) : [];
            }
            catch (e) {
                console.error("Error parsing search history from localStorage:", e);
                return [];
            }
        }

        function saveSearchHistory(history) {
            try {
                localStorage.setItem('searchHistory', JSON.stringify(history));
            } catch (e) {
                console.error("Error saving search history to localStorage:", e);
            }
        }

        function addSearchToHistory(query, engine) {
            const history = getSearchHistory();
            const now = new Date();
            const timestamp = now.toISOString();
            history.unshift({ query, engine, timestamp });
            if (history.length > 20) {
                history.pop();
            }
            saveSearchHistory(history);
            renderSearchHistory();
        }

        function renderSearchHistory() {
            const history = getSearchHistory();
            historyList.innerHTML = '';

            if (history.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No search history yet.';
                li.classList.add('text-text-placeholder', 'text-center', 'p-4');
                historyList.appendChild(li);
                return;
            }

            history.forEach(item => {
                const li = document.createElement('li');
                li.className = 'history-item flex items-center py-1.5 border-b border-dashed text-base cursor-pointer gap-2 hover:bg-primary-bg ' +
                               'border-border-color text-text-primary ' +
                               'dark:border-dark-border-color dark:hover:bg-dark-primary-bg dark:text-dark-text-primary';

                const engineTag = document.createElement('span');
                engineTag.className = 'history-engine-tag text-[0.65rem] px-1.5 py-0.5 rounded-sm uppercase flex-shrink-0 ' +
                                      'bg-border-color text-text-primary ' +
                                      'dark:bg-dark-border-color dark:text-dark-text-primary';
                engineTag.textContent = item.engine;

                const querySpan = document.createElement('span');
                querySpan.className = 'history-query flex-grow whitespace-nowrap overflow-hidden text-ellipsis';
                querySpan.textContent = item.query;

                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'history-timestamp text-[0.7rem] ml-auto flex-shrink-0 ' +
                                          'text-text-secondary dark:text-dark-text-secondary';
                timestampSpan.textContent = formatTimeAgo(item.timestamp);

                const openLinkButton = document.createElement('button');
                openLinkButton.className = 'open-link-button bg-none border-none cursor-pointer p-0 flex items-center justify-center ml-2 flex-shrink-0 hover:text-text-primary ' +
                                           'text-text-secondary dark:text-dark-text-secondary dark:hover:text-dark-text-primary';
                openLinkButton.setAttribute('title', `Open in ${item.engine}`);
                openLinkButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="open-link-icon">
                        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" x2="21" y1="14" y2="3"/>
                    </svg>
                `;
                openLinkButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    let url = '';
                    switch (item.engine) {
                        case 'google':
                            url = `https://www.google.com/search?q=${encodeURIComponent(item.query)}`;
                            break;
                        case 'perplexity':
                            url = `https://www.perplexity.ai/search?q=${encodeURIComponent(item.query)}`;
                            break;
                        case 'youtube':
                            url = `https://www.youtube.com/results?search_query=${encodeURIComponent(item.query)}`;
                            break;
                        case 'chatgpt':
                            url = `https://chat.openai.com/chat?q=${encodeURIComponent(item.query)}`;
                            break;
                        default:
                            url = `https://www.google.com/search?q=${encodeURIComponent(item.query)}`;
                            break;
                    }
                    window.open(url, '_blank');
                });

                li.appendChild(engineTag);
                li.appendChild(querySpan);
                li.appendChild(timestampSpan);
                li.appendChild(openLinkButton);

                historyList.appendChild(li);
            });
        }

        function updateGoalTimeSince() {
            // Only render goals if they are enabled
            if (goalsEnabled) {
                renderGoals();
            }
        }

        function updateActiveLinePosition() {
            const currentRadio = document.querySelector('input[name="engine"]:checked');
            const activeLineElement = document.getElementById('active-line');
            if (currentRadio && activeLineElement) {
                const parentLabel = currentRadio.closest('.engine-label');
                if (parentLabel) {
                    // Get the position and size relative to the parent .engine-selection
                    const parentRect = engineSelection.getBoundingClientRect();
                    const labelRect = parentLabel.getBoundingClientRect();

                    const newLeft = `${labelRect.left - parentRect.left}px`;
                    const newWidth = `${labelRect.width}px`;

                    activeLineElement.style.left = newLeft;
                    activeLineElement.style.width = newWidth;
                }
            }
        }

        function updateActiveLineAndSections() {
            let historySelected = false;
            radioButtons.forEach(radio => {
                if (radio.checked) {
                    // Update search input placeholder based on selected engine
                    searchInput.placeholder = searchEnginePlaceholders[radio.value];
                    if (radio.value === 'history') {
                        historySelected = true;
                    }
                }
            });

            // Defer updateActiveLinePosition to ensure layout is stable
            setTimeout(updateActiveLinePosition, 0); 

            if (searchHistorySection) {
                if (historySelected) {
                    searchHistorySection.classList.add('show');
                    renderSearchHistory();
                } else {
                    searchHistorySection.classList.remove('show');
                }
            }
        }

        // --- Element References ---
        const searchForm = document.getElementById('search-form');
        const searchInput = document.getElementById('search-input');
        const radioButtons = document.querySelectorAll('input[name="engine"]');
        const timeIconElement = document.getElementById('time-icon');
        const currentTimeSpan = document.getElementById('current-time');
        const blankScreenOverlay = document.getElementById('blank-screen-overlay');
        const engineSelection = document.getElementById('engine-selection'); // Reference to the engine selection container

        const goalsContainer = document.getElementById('goals-container');
        const goalContextMenu = document.getElementById('goal-context-menu');

        const editGoalSection = document.getElementById('edit-goal-section');
        const editGoalInput = document.getElementById('edit-goal-input');
        const editGoalActionButton = document.getElementById('edit-goal-action-button');
        const editGoalDeleteButton = document.getElementById('edit-goal-delete-button');

        const searchHistorySection = document.getElementById('search-history-section');
        const historyList = document.getElementById('history-list');
        const clearHistoryButton = document.getElementById('clear-history-button');

        // Elements for More menu and theme toggle
        const moreButton = document.getElementById('more-button');
        const moreMenu = document.getElementById('more-menu');
        const themeToggleButton = document.getElementById('theme-toggle');
        const tasksToggleButton = document.getElementById('tasks-toggle'); // New tasks toggle button

        const topElementsContainer = document.getElementById('top-elements');
        const mainContentBottomContainer = document.getElementById('main-content-bottom');

        // Global flag to track if Ctrl/Cmd is pressed
        let isCtrlPressed = false;
        let goalsEnabled = false; // State variable for goals visibility


        // Function to apply theme
        function applyTheme(theme) {
            const html = document.documentElement; // Target the html element for dark mode class
            const activeLine = document.getElementById('active-line'); // Get the active line element

            if (theme === 'light') {
                html.classList.remove('dark');
                themeToggleButton.textContent = 'Dark Mode';
                // Set active line color for light mode explicitly
                if (activeLine) activeLine.style.backgroundColor = '#1a1a1a'; // Dark color for light mode
            } else { // 'dark' theme
                html.classList.add('dark');
                themeToggleButton.textContent = 'Light Mode';
                // Set active line color for dark mode explicitly
                if (activeLine) activeLine.style.backgroundColor = '#ffffff'; // White for dark mode
            }
            localStorage.setItem('themePreference', theme);
        }

        // Function to toggle goals visibility and update layout
        function toggleGoals() {
            goalsEnabled = !goalsEnabled;
            localStorage.setItem('goalsEnabled', goalsEnabled);
            updateLayout(); // Call updateLayout to handle DOM changes and button text
            moreMenu.classList.remove('show'); // Close menu after selection
            setTimeout(() => {
                moreMenu.style.visibility = 'hidden';
                moreMenu.style.pointerEvents = 'none';
            }, 200);
        }

        function updateLayout() {
            if (goalsEnabled) {
                goalsContainer.classList.remove('hidden');
                tasksToggleButton.textContent = 'Disable Tasks';
                // Move engine-selection to top-elements
                topElementsContainer.appendChild(engineSelection);
                topElementsContainer.classList.add('with-engine');
            } else {
                goalsContainer.classList.add('hidden');
                tasksToggleButton.textContent = 'Enable Tasks';
                // Move engine-selection to main-content-bottom
                mainContentBottomContainer.prepend(engineSelection); // Add to the beginning of bottom section
                topElementsContainer.classList.remove('with-engine');
            }
            renderGoals(); // Re-render goals based on new visibility state
            // Ensure updateActiveLinePosition runs after DOM changes are processed
            setTimeout(updateActiveLinePosition, 0); 
        }


        // Event listener for context menu items
        goalContextMenu.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (action) {
                handleContextMenuAction(action);
            }
        });

        // Hide context menu, edit goal popup if clicked anywhere outside them
        document.addEventListener('click', (e) => {
            if (!goalContextMenu.contains(e.target) && goalContextMenu.classList.contains('show')) {
                hideGoalContextMenu();
            }
            // Check if the click is outside the edit goal modal and it's currently shown
            if (editGoalSection.classList.contains('show') && !editGoalModal.contains(e.target)) {
                hideEditGoalPopup();
            }
            // Hide more menu if clicked outside
            if (moreMenu.classList.contains('show') && !moreMenu.contains(e.target) && e.target !== moreButton) {
                moreMenu.classList.remove('show');
                // Use a timeout to hide visibility after transition completes
                setTimeout(() => {
                    moreMenu.style.visibility = 'hidden';
                    moreMenu.style.pointerEvents = 'none';
                }, 200); // Match transition-duration of opacity/transform
            }
        });

        // Add escape key listener
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (editGoalSection.classList.contains('show')) {
                    hideEditGoalPopup();
                }
                if (moreMenu.classList.contains('show')) {
                    moreMenu.classList.remove('show');
                    // Use a timeout to hide visibility after transition completes
                    setTimeout(() => {
                        moreMenu.style.visibility = 'hidden';
                        moreMenu.style.pointerEvents = 'none';
                    }, 200); // Match transition-duration of opacity/transform
                }
            }
        });

        // Add Enter key listener for the goal input
        editGoalInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent default form submission or new line
                handleEditGoalAction();
            }
        });

        // Listen for changes on radio buttons to update the active line and sections visibility
        radioButtons.forEach(radio => {
            radio.addEventListener('change', updateActiveLineAndSections);
        });

        // Clear history button listener
        if (clearHistoryButton) {
            clearHistoryButton.addEventListener('click', () => {
                localStorage.removeItem('searchHistory');
                renderSearchHistory();
            });
        }

        // Track Ctrl/Cmd key state
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Control' || e.key === 'Meta') {
                isCtrlPressed = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Control' || e.key === 'Meta') {
                isCtrlPressed = false;
            }
        });

        // --- Form Submission Logic ---
        searchForm.addEventListener('submit', function (e) {
            e.preventDefault();
            let query = searchInput.value.trim();
            if (!query) return;

            let selectedEngine = document.querySelector('input[name="engine"]:checked').value;

            // If history is active, switch to Google before searching
            if (selectedEngine === 'history') {
                const googleRadio = document.querySelector('input[name="engine"][value="google"]');
                if (googleRadio) {
                    googleRadio.checked = true;
                    googleRadio.dispatchEvent(new Event('change')); // Trigger change to update UI
                    selectedEngine = 'google'; // Update selectedEngine for the URL construction
                }
            }

            let url = '';

            switch (selectedEngine) {
                case 'google':
                    url = `https://www.google.com/search?q=${encodeURIComponent(query)}`;
                    break;
                case 'perplexity':
                    url = `https://www.perplexity.ai/search?q=${encodeURIComponent(query)}`;
                    break;
                case 'youtube':
                    url = `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`;
                    break;
                case 'chatgpt':
                    url = `https://chat.openai.com/chat?q=${encodeURIComponent(query)}`;
                    break;
                // No default case needed as history is handled above and other cases are explicit
            }

            if (selectedEngine !== 'history') { // Only add to history if it's an actual search engine
                addSearchToHistory(query, selectedEngine);
            }

            blankScreenOverlay.style.opacity = '1';
            blankScreenOverlay.style.pointerEvents = 'auto';

            // Check if Ctrl key (or Cmd key on Mac) was pressed using the global flag
            if (isCtrlPressed) {
                window.open(url, '_blank');
            } else {
                setTimeout(() => {
                    window.location.href = url;
                }, 200);
            }
        });

        // --- Keyboard Shortcut Logic ---
        document.addEventListener('keydown', function(e) {
            const key = e.key.toLowerCase();

            const isInputActive = document.activeElement.tagName === 'INPUT' ||
                                  document.activeElement.tagName === 'TEXTAREA' ||
                                  document.activeElement.tagName === 'SELECT';

            if (!isInputActive && key !== '/' && key !== 'escape') {
                let targetEngine = null;

                if (key === 'p') {
                    targetEngine = 'perplexity';
                } else if (key === 'g') {
                    targetEngine = 'google';
                } else if (key === 'y') {
                    targetEngine = 'youtube';
                } else if (key === 'c') {
                    targetEngine = 'chatgpt';
                } else if (key === 'h') {
                    targetEngine = 'history';
                } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault(); // Prevent default browser scrolling

                    const currentRadio = document.querySelector('input[name="engine"]:checked');
                    let currentIndex = -1;
                    // Get all engine labels to determine order for arrow key navigation
                    const engineLabels = Array.from(document.querySelectorAll('.engine-label input[name="engine"]'));

                    for (let i = 0; i < engineLabels.length; i++) {
                        if (engineLabels[i] === currentRadio) {
                            currentIndex = i;
                            break;
                        }
                    }

                    let newIndex = currentIndex;
                    if (e.key === 'ArrowRight') {
                        newIndex = (currentIndex + 1) % engineLabels.length;
                    } else if (e.key === 'ArrowLeft') {
                        newIndex = (currentIndex - 1 + engineLabels.length) % engineLabels.length;
                    }

                    if (newIndex !== currentIndex) {
                        engineLabels[newIndex].checked = true;
                        engineLabels[newIndex].dispatchEvent(new Event('change')); // Trigger change event
                    }
                    return; // Exit to prevent other keydown logic from interfering
                }

                if (targetEngine) {
                    e.preventDefault();
                    const radioToSelect = document.querySelector(`input[name="engine"][value="${targetEngine}"]`);
                    if (radioToSelect) {
                        radioToSelect.checked = true;
                        radioToSelect.dispatchEvent(new Event('change'));
                    }
                }
            }

            if (key === '/') {
                e.preventDefault();
                searchInput.focus();
            }

            if (key === 'escape' && document.activeElement === searchInput) {
                searchInput.blur();
            }
        });

        // Function to initialize the app
        function initializeApp() {
            // Element reference for editGoalModal
            window.editGoalModal = document.querySelector('#edit-goal-section .edit-goal-modal');

            // Event listener for the new combined action button
            if (editGoalActionButton) {
                editGoalActionButton.addEventListener('click', handleEditGoalAction);
            }
            // Event listener for the delete button
            if (editGoalDeleteButton) {
                editGoalDeleteButton.addEventListener('click', handleDeleteGoal);
            }
            // Event listener for input changes to update action button text
            if (editGoalInput) {
                editGoalInput.addEventListener('input', updateActionButtonText);
            }

            // Also update active line on window resize to handle responsive changes
            window.addEventListener('resize', updateActiveLinePosition);

            setInterval(updateDayProgress, 60 * 1000);
            setInterval(updateGoalTimeSince, 60 * 1000); // This will now conditionally render goals
            setInterval(updateTimeOfDayInfo, 60 * 1000);

            // Apply saved preferences directly
            // This ensures theme-dependent elements like active-line color and theme-toggle text are set.
            applyTheme(localStorage.getItem('themePreference') || 'light'); // Default to light if not set

            goalsEnabled = localStorage.getItem('goalsEnabled') === 'true'; // Default to false if not set
            updateLayout();
            updateDayProgress();
            updateTimeOfDayInfo();
            renderSearchHistory();
            updateActiveLineAndSections(); // Initial setup for engine selector
            
            // Ensure loading overlay is off
            blankScreenOverlay.style.opacity = '0'; 
            blankScreenOverlay.style.pointerEvents = 'none';


            // Event listener for theme toggle button (now inside the more menu)
            themeToggleButton.addEventListener('click', () => {
                const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                applyTheme(newTheme);
                moreMenu.classList.remove('show'); // Close menu after selection
                // Use a timeout to hide visibility after transition completes
                setTimeout(() => {
                    moreMenu.style.visibility = 'hidden';
                    moreMenu.style.pointerEvents = 'none';
                }, 200); // Match transition-duration of opacity/transform
            });

            // Event listener for Tasks toggle button
            tasksToggleButton.addEventListener('click', toggleGoals);

            // Event listener for More button
            moreButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent document click from immediately closing it
                moreMenu.classList.toggle('show');
                // Toggle visibility to allow transitions
                if (moreMenu.classList.contains('show')) {
                    moreMenu.style.visibility = 'visible';
                    moreMenu.style.pointerEvents = 'auto';
                } else {
                    // Use a timeout to hide visibility after transition completes
                    setTimeout(() => {
                        moreMenu.style.visibility = 'hidden';
                        moreMenu.style.pointerEvents = 'none';
                    }, 200); // Match transition-duration of opacity/transform
                }
            });
        }


        // Initial call when the DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp(); // Call directly without delay
        });

        // Fix for blank screen on browser back button
        window.addEventListener('pageshow', (event) => {
            // Check if the page is being shown from the bfcache (back-forward cache)
            // This means the user navigated back to the page.
            if (event.persisted) {
                blankScreenOverlay.style.opacity = '0';
                blankScreenOverlay.style.pointerEvents = 'none';
            }
        });
    </script>
</body>
</html>
